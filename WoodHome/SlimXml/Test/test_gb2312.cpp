///////////////////////////////////////////////////////////////////////////////////////////////////
//this file is automatically generated, do not modify.
///////////////////////////////////////////////////////////////////////////////////////////////////
#include "test_gb2312.h"
#include <cassert>

using namespace slim;

namespace test_gb2312
{
///////////////////////////////////////////////////////////////////////////////////////////////////
void Model::read( const XmlNode* node )
{
	assert( node != NULL );

	NodeIterator iter;
	const XmlNode* childNode = NULL;
	const XmlAttribute* attribute = NULL;

	childNode = node->findChild( "Skeleton" );
	if ( childNode != NULL )
	{
		Skeleton = childNode->getString();
	}

	childNode = node->findFirstChild( "Part", iter );
	while ( childNode != NULL )
	{
		Parts.resize( Parts.size() + 1 );
		Parts.back().read( childNode );
		childNode = node->findNextChild( "Part", iter );
	}

	childNode = node->findFirstChild( "Animation", iter );
	while ( childNode != NULL )
	{
		Animations.resize( Animations.size() + 1 );
		Animations.back().read( childNode );
		childNode = node->findNextChild( "Animation", iter );
	}

	childNode = node->findFirstChild( "Light", iter );
	while ( childNode != NULL )
	{
		Lights.resize( Lights.size() + 1 );
		Lights.back().read( childNode );
		childNode = node->findNextChild( "Light", iter );
	}

	childNode = node->findChild( "Window" );
	if ( childNode != NULL )
	{
		Window.read( childNode );
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Model::write( XmlNode* node ) const
{
	assert( node != NULL );

	node->clearChild();
	node->clearAttribute();

	XmlNode* childNode = NULL;
	XmlAttribute* attribute = NULL;

	if ( Skeleton != "" )
	{
		childNode = node->addChild( "Skeleton" );
		childNode->setString( Skeleton );
	}

	for ( std::vector<Part>::const_iterator iter = Parts.begin();
		  iter != Parts.end();
		  ++iter )
	{
		const Part& obj = *iter;
		childNode = node->addChild( "Part" );
		obj.write( childNode );
	}

	for ( std::vector<Animation>::const_iterator iter = Animations.begin();
		  iter != Animations.end();
		  ++iter )
	{
		const Animation& obj = *iter;
		childNode = node->addChild( "Animation" );
		obj.write( childNode );
	}

	for ( std::vector<Light>::const_iterator iter = Lights.begin();
		  iter != Lights.end();
		  ++iter )
	{
		const Light& obj = *iter;
		childNode = node->addChild( "Light" );
		obj.write( childNode );
	}

	childNode = node->addChild( "Window" );
	Window.write( childNode );
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Part::read( const XmlNode* node )
{
	assert( node != NULL );

	NodeIterator iter;
	const XmlNode* childNode = NULL;
	const XmlAttribute* attribute = NULL;

	attribute = node->findAttribute( "Slot" );
	if ( attribute != NULL )
	{
		Slot = attribute->getString();
	}

	attribute = node->findAttribute( "Filename" );
	if ( attribute != NULL )
	{
		Filename = attribute->getString();
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Part::write( XmlNode* node ) const
{
	assert( node != NULL );

	node->clearChild();
	node->clearAttribute();

	XmlNode* childNode = NULL;
	XmlAttribute* attribute = NULL;

	if ( Slot != "" )
	{
		attribute = node->addAttribute( "Slot" );
		attribute->setString( Slot );
	}

	if ( Filename != "" )
	{
		attribute = node->addAttribute( "Filename" );
		attribute->setString( Filename );
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Animation::read( const XmlNode* node )
{
	assert( node != NULL );

	NodeIterator iter;
	const XmlNode* childNode = NULL;
	const XmlAttribute* attribute = NULL;

	attribute = node->findAttribute( "Slot" );
	if ( attribute != NULL )
	{
		Slot = attribute->getString();
	}

	attribute = node->findAttribute( "Filename" );
	if ( attribute != NULL )
	{
		Filename = attribute->getString();
	}

	childNode = node->findFirstChild( "Event", iter );
	while ( childNode != NULL )
	{
		Events.resize( Events.size() + 1 );
		Events.back().read( childNode );
		childNode = node->findNextChild( "Event", iter );
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Animation::write( XmlNode* node ) const
{
	assert( node != NULL );

	node->clearChild();
	node->clearAttribute();

	XmlNode* childNode = NULL;
	XmlAttribute* attribute = NULL;

	if ( Slot != "" )
	{
		attribute = node->addAttribute( "Slot" );
		attribute->setString( Slot );
	}

	if ( Filename != "" )
	{
		attribute = node->addAttribute( "Filename" );
		attribute->setString( Filename );
	}

	for ( std::vector<Event>::const_iterator iter = Events.begin();
		  iter != Events.end();
		  ++iter )
	{
		const Event& obj = *iter;
		childNode = node->addChild( "Event" );
		obj.write( childNode );
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Event::read( const XmlNode* node )
{
	assert( node != NULL );

	NodeIterator iter;
	const XmlNode* childNode = NULL;
	const XmlAttribute* attribute = NULL;

	attribute = node->findAttribute( "Time" );
	if ( attribute != NULL )
	{
		Time = attribute->getFloat();
	}

	attribute = node->findAttribute( "Type" );
	if ( attribute != NULL )
	{
		Type = attribute->getString();
	}

	childNode = node->findFirstChild( "Param", iter );
	while ( childNode != NULL )
	{
		Params.resize( Params.size() + 1 );
		Params.back() = childNode->getString();
		childNode = node->findNextChild( "Param", iter );
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Event::write( XmlNode* node ) const
{
	assert( node != NULL );

	node->clearChild();
	node->clearAttribute();

	XmlNode* childNode = NULL;
	XmlAttribute* attribute = NULL;

	if ( Time != 0.0f )
	{
		attribute = node->addAttribute( "Time" );
		attribute->setFloat( Time );
	}

	if ( Type != "" )
	{
		attribute = node->addAttribute( "Type" );
		attribute->setString( Type );
	}

	for ( std::vector<std::string>::const_iterator iter = Params.begin();
		  iter != Params.end();
		  ++iter )
	{
		const std::string& value = *iter;
		childNode = node->addChild( "Param" );
		childNode->setString( value );
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Light::read( const XmlNode* node )
{
	assert( node != NULL );

	NodeIterator iter;
	const XmlNode* childNode = NULL;
	const XmlAttribute* attribute = NULL;

	childNode = node->findChild( "Position" );
	if ( childNode != NULL )
	{
		Position = childNode->getString();
	}

	childNode = node->findChild( "Bone" );
	if ( childNode != NULL )
	{
		Bone = childNode->getString();
	}

	childNode = node->findChild( "Range" );
	if ( childNode != NULL )
	{
		Range = childNode->getFloat();
	}

	childNode = node->findChild( "Color" );
	if ( childNode != NULL )
	{
		Color = childNode->getString();
	}

	childNode = node->findChild( "AttenConst" );
	if ( childNode != NULL )
	{
		AttenConst = childNode->getFloat();
	}

	childNode = node->findChild( "AttenLinear" );
	if ( childNode != NULL )
	{
		AttenLinear = childNode->getFloat();
	}

	childNode = node->findChild( "AttenQuad" );
	if ( childNode != NULL )
	{
		AttenQuad = childNode->getFloat();
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Light::write( XmlNode* node ) const
{
	assert( node != NULL );

	node->clearChild();
	node->clearAttribute();

	XmlNode* childNode = NULL;
	XmlAttribute* attribute = NULL;

	if ( Position != "" )
	{
		childNode = node->addChild( "Position" );
		childNode->setString( Position );
	}

	if ( Bone != "" )
	{
		childNode = node->addChild( "Bone" );
		childNode->setString( Bone );
	}

	if ( Range != 0.0f )
	{
		childNode = node->addChild( "Range" );
		childNode->setFloat( Range );
	}

	if ( Color != "" )
	{
		childNode = node->addChild( "Color" );
		childNode->setString( Color );
	}

	if ( AttenConst != 0.0f )
	{
		childNode = node->addChild( "AttenConst" );
		childNode->setFloat( AttenConst );
	}

	if ( AttenLinear != 0.0f )
	{
		childNode = node->addChild( "AttenLinear" );
		childNode->setFloat( AttenLinear );
	}

	if ( AttenQuad != 0.0f )
	{
		childNode = node->addChild( "AttenQuad" );
		childNode->setFloat( AttenQuad );
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Window::read( const XmlNode* node )
{
	assert( node != NULL );

	NodeIterator iter;
	const XmlNode* childNode = NULL;
	const XmlAttribute* attribute = NULL;

	attribute = node->findAttribute( "Type" );
	if ( attribute != NULL )
	{
		Type = attribute->getString();
	}

	attribute = node->findAttribute( "Name" );
	if ( attribute != NULL )
	{
		Name = attribute->getString();
	}

	childNode = node->findFirstChild( "Property", iter );
	while ( childNode != NULL )
	{
		Properties.resize( Properties.size() + 1 );
		Properties.back().read( childNode );
		childNode = node->findNextChild( "Property", iter );
	}

	childNode = node->findFirstChild( "Window", iter );
	while ( childNode != NULL )
	{
		Windows.resize( Windows.size() + 1 );
		Windows.back().read( childNode );
		childNode = node->findNextChild( "Window", iter );
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Window::write( XmlNode* node ) const
{
	assert( node != NULL );

	node->clearChild();
	node->clearAttribute();

	XmlNode* childNode = NULL;
	XmlAttribute* attribute = NULL;

	if ( Type != "" )
	{
		attribute = node->addAttribute( "Type" );
		attribute->setString( Type );
	}

	if ( Name != "" )
	{
		attribute = node->addAttribute( "Name" );
		attribute->setString( Name );
	}

	for ( std::vector<Property>::const_iterator iter = Properties.begin();
		  iter != Properties.end();
		  ++iter )
	{
		const Property& obj = *iter;
		childNode = node->addChild( "Property" );
		obj.write( childNode );
	}

	for ( std::vector<Window>::const_iterator iter = Windows.begin();
		  iter != Windows.end();
		  ++iter )
	{
		const Window& obj = *iter;
		childNode = node->addChild( "Window" );
		obj.write( childNode );
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Property::read( const XmlNode* node )
{
	assert( node != NULL );

	NodeIterator iter;
	const XmlNode* childNode = NULL;
	const XmlAttribute* attribute = NULL;

	attribute = node->findAttribute( "Name" );
	if ( attribute != NULL )
	{
		Name = attribute->getString();
	}

	attribute = node->findAttribute( "Value" );
	if ( attribute != NULL )
	{
		Value = attribute->getString();
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void Property::write( XmlNode* node ) const
{
	assert( node != NULL );

	node->clearChild();
	node->clearAttribute();

	XmlNode* childNode = NULL;
	XmlAttribute* attribute = NULL;

	if ( Name != "" )
	{
		attribute = node->addAttribute( "Name" );
		attribute->setString( Name );
	}

	if ( Value != "" )
	{
		attribute = node->addAttribute( "Value" );
		attribute->setString( Value );
	}
}

}
